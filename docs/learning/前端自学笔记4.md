# 前端自学笔记-第三篇(0825)

**目录**
[[toc]]



## 一、通过AE+GKA，一键制作前端动画

### 思路
前端动画之前都是设计给动画，然后一帧一帧的去调，中间会出现反复的协商调整。

而通过AE导致每一帧图片，然后再利用GKA npm插件，一键导出css/canvas/svg/createJs 动画，效果还是非常不错的。gka,还可以自动生成雪碧图，代码压缩。简直是前端制作动画的神器。

### 参考文章
下面是我参照的文章，然后自己做了一个demo：

**初识Adobe After Effects效果制作**： <https://aotu.io/notes/2015/12/29/ae/>
ps: AE动画小巧挺多的，可以动手照着做一个，加强对于AE的了解，不难，挺像ps的。

**GKA官网**：<https://gka.js.org/#/>

gka使用超级简单
```js
增加模板
模板支持动态增加，只需安装需要的模板。即时安装，即刻可用。

npm i gka-tpl-模板名 -g
使用示例
对 E:\img 目录中的图片进行处理。

快速生成帧动画
gka E:\img
进行图片去重、合图优化，输出 css 动画文件
gka E:\img -us
进行图片去重、空白裁剪、合图优化，使用 canvas 模板，输出 canvas 动画文件
gka E:\img -ucs -t canvas
```

###  DEMO
下面是我制作的demo,丑是丑了点，但是原理实现了

这是通过Adobe After Effects制作的效果
![不使用别名引用](~@learning/6.png)


通过AE导出每一帧图片，然后通过GKA生成的效果。
扫描二维码可以查看效果

最下面的gif图片，是通过ps合成的。
![不使用别名引用](~@learning/4.png)


## 二、canvas动效框架createJs

### 使用教程链接
CreateJS入门 -- 注释详细到爆炸（My Style）:<https://juejin.im/post/5b4eff0de51d4517580ddfa9>

官网API: <http://www.createjs.cc/src/docs/easeljs/classes/Bitmap.html#property_mask>

### 心得

公司偏动效开发，而热门产品的动效使用的正是createJs技术。自己也很快要开发类似产品，相关的技术也要学起来，作为储备。

通过两三个早上的学习，createJs学起来还是比canvas简单，毕竟他跟vue框架一样是封装好的，调取api即可。

本次学习createJS不同以往，之前主要是跟着别人的思路走：要么是纯教程或者视频。而跟着别人走，虽然看似节省时间，但对于技术的整体脉络会比较片面，只是掌握了教材中教的技术而已。

这次主要是看官方的文档，再去整理笔记，不断消化主要的api。这种学习方式比上面的效率反而更高，学习方式也是可持续的。

当然这种学习方法也是有前提的，最好是官网文档比较齐全，入门教容易的，太难的还是其他的方法吧。



## 三、vue+js: 预览图随着滚动条平滑移动

### 技术要点

1. 产品需求很简单，只是预览图能够拖动就行。想着顺便做一个随着滚动条移动的效果，这样体验会更好。

2. **技术难点：**

+ 在mounted中获取全局以及局部滚动条的高度
* 因为是在vue项目中操作dom，且不使用jQuery的情况下。要让滚动条平滑移动，这里采用的是网上分段的方法，然后递归去递增或者递减。
+ 涉及到向上和向下滚动，滚动的临界点，如果快速上下滚动，会发生抖动。我是加了锁，而且把临界点隔开几像素来避免。
- 为了让滚动条始终保持在底部，可以采用：scrollTop=scrollHeight-clientHeight

### 代码参考
```js
<template>
    <div class="content" ref='mobileRef'> // 固定高度
        <div class='content-scroll' ></div>
    </div>
</template>

<script>
    data () {
        return {
            once: true
        }
    },
    mounted() {
        // 监听页面内div元素滚动条
        // this.$refs.mobileRef.addEventListener('scroll', ()=>{
        //         console.log('scrollHeight', this.$refs.mobileRef.scrollHeight)
        //         if(this.form.backgroundImg) {
        //             this.$refs.mobileRef.scrollTop = this.$refs.mobileRef.scrollHeight 
        //         }
        //         console.log(" scroll " + this.$refs.mobileRef.scrollTop)
        // }, false)
        this.$nextTick(function () {
            window.addEventListener('scroll', this.onScroll) // 监听滚动条
        })
    },
    methods: {
        onScroll () {
            let that = this
            let scrolled = document.documentElement.scrollTop || document.body.scrollTop // 获取滚动条srcollTop
            let step = ''
            if(this.form.backgroundImg) {
                let divHeight =  that.$refs.mobileRef.scrollHeight // 左侧元素的滚动条高度
                let divClient = that.$refs.mobileRef.clientHeight // 滚动条本身的高度
                step =  divHeight/50  // 平滑滚动，设置了50，后面设置定时器，每10秒变化一次
                if(scrolled <705 && this.once == false ) {  // once锁一定要是全局的，不能设置在方法onScroll中
                    smoothUp()
                } else if(scrolled >710 &&  this.once == true) { // 为了形成互斥效果，两边都需要判断scrolled的高度，以及互斥锁
                    smoothDown()
                }
         
                function smoothDown() {

                    if(that.$refs.mobileRef.scrollTop <divHeight-divClient) { // divHeight-divClient 就是srcollTOP的最大高度
                        that.$refs.mobileRef.scrollTop += step
                        // 递归，会一直调用，直到return false .递归的出口是：that.$refs.mobileRef.scrollTop =divHeight-divClient
                        setTimeout(smoothDown, 10)                         
                    } else {
                        setTimeout(()=>{  // 锁设置了定时器，主要是为了防止scrolled 在710的节点出现快速上下滑动出现的抖动行为
                            that.once = false
                        }, 200 )
                    }
                }
                function smoothUp() {
                    if(that.$refs.mobileRef.scrollTop > 0) {
                        that.$refs.mobileRef.scrollTop -= step
                        setTimeout(smoothUp, 10) // 递归的出口是：that.$refs.mobileRef.scrollTop = 0
                    } else {
                        setTimeout(()=>{
                            that.once = true
                        }, 200 )
                    }
                }
            } 
        }
    }

</script>

```



